## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE, 
                      warning = FALSE, 
                      collapse = TRUE,
                      comment = "#>"
                      )


## ----loading_packages, include=TRUE-------------------------------------------
library("bpmodels")
library('dplyr')
library('ggplot2')
library('lubridate')

## ----data_generation, message=FALSE-------------------------------------------
set.seed(12)
cases_df <- data.frame(date = as.Date('2023-01-01') + seq_len(12),
                       cases = rnbinom(12, size = 7.5, mu = 5)
                       )
head(cases_df)

ggplot(cases_df, 
       aes(x = date, y = cases)
       ) + 
  geom_col(fill = 'tomato3', size = 1)

## ----input_prep, message=FALSE------------------------------------------------
# We will create a vector of starting times for each case, using the time of the index cases as the reference point
cases_df$days_since_index <- as.integer(cases_df$date - min(cases_df$date))

#'Disaggregate the time series 
case_times <- unlist(mapply(function(x, y) rep(x, times = ifelse(y == 0, 1, y)), 
                       cases_df$days_since_index, 
                       cases_df$cases
                       )
                       )
                       


#' Date to end simulation (14 day projection in this case)
projection_window <- 14 #2 week ahead projection
project_to_date <- max(cases_df$days_since_index) + projection_window 


#' Number of simulations and maximum chain size
sim_rep <- 1000
cases_to_project <- 1000


### Specifying the `serial` argument to `chain_sim()`
#' Assume serial interval follows log-normal distribution with mean, mu = 4.7, 
#' and standard deviation, sigma = 2.9, then the desired standard deviation, si_sd, 
#' and mean, si_mean, are
sigma = 2.9
mu = 4.7

si_sd <- sqrt(log(1 + (sigma/mu)^2)) #log standard deviation
si_mean <- log((mu^2)/(sqrt(sigma^2 + mu^2))) #log mean

#' serial interval function
serial_interval <- function(sample_size) {
  si <- rlnorm(sample_size, meanlog = si_mean, sdlog = si_sd)
  return(si)
}

## ----simulations, message=FALSE-----------------------------------------------
## Chain log-likelihood simulation
sim_chain_sizes <- lapply(seq_len(sim_rep),
                           function(sim){chain_sim(
                               n = length(case_times),
                               offspring = "nbinom",
                               mu = 2.0,
                               size = 0.38,
                               stat = "size",
                               infinite = cases_to_project,
                               serial = serial_interval,
                               t0 = case_times,
                               tf = project_to_date,
                               tree = TRUE
                           ) |> 
                               mutate(sim = sim)} 
                          )

sim_output <- do.call(rbind, sim_chain_sizes) 

## ----post_processing----------------------------------------------------------
ref_date <- min(cases_df$date)

incidence_ts <- sim_output |> 
  mutate(day = floor(time)) |> 
  group_by(sim, day) |> 
  summarise(cases = n()) |>  
  ungroup()


## Median cases by date.  
median_daily_cases <- incidence_ts |>
  group_by(day)|>
  summarise(median_cases = median(cases)) |>
  ungroup()|>
  arrange(day) |>
  mutate(date = ymd(ref_date) + 0:(project_to_date - 1))


## ----visualisation------------------------------------------------------------
# Visualization
cases_plot <- ggplot(data = median_daily_cases) +
  geom_col(aes(x = date, y = median_cases),
           fill = "tomato3",
           size = 1
  ) +
  scale_y_continuous(breaks = seq(0, max(median_daily_cases$median_cases) + 20, 20),
                     labels = seq(0, max(median_daily_cases$median_cases) + 20, 20)
  ) +
  labs(x = 'Date', y = 'Daily cases (median)') + 
  theme_minimal(base_size = 14)

print(cases_plot)

